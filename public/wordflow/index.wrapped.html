<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>WordFlow - 영단어 집중 암기</title>
    
    <!-- Fonts: Pretendard & Noto Sans KR for optimal readability -->
    <link rel="stylesheet" as="style" crossorigin href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.9/dist/web/static/pretendard.min.css" />
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
    
    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              brand: {
                50: '#f0f9ff',
                100: '#e0f2fe',
                500: '#0ea5e9',
                600: '#0284c7',
                900: '#0c4a6e',
              },
              focus: '#8b5cf6',
              success: '#10b981',
              error: '#ef4444',
            },
            fontFamily: {
              sans: ['Pretendard', 'Noto Sans KR', 'Apple SD Gothic Neo', 'Malgun Gothic', 'sans-serif'],
            },
            animation: {
              'flip': 'flip 0.6s preserve-3d',
            }
          },
        },
      }
    </script>
    <style>
      body {
        font-family: 'Pretendard', 'Noto Sans KR', sans-serif;
        background-color: #f8fafc;
        overflow-x: hidden;
      }
      .backface-hidden {
        backface-visibility: hidden;
        -webkit-backface-visibility: hidden;
      }
      .rotate-y-180 {
        transform: rotateY(180deg);
      }
      .perspective-1000 {
        perspective: 1000px;
      }
      .preserve-3d {
        transform-style: preserve-3d;
      }
      /* Custom scrollbar for cards */
      .scrollbar-hide::-webkit-scrollbar {
          display: none;
      }
      .scrollbar-hide {
          -ms-overflow-style: none;
          scrollbar-width: none;
      }
    </style>
  
<link rel="stylesheet" href="./index.css">
</head>
  <body>
    <div id="root"></div>
  

     <!-- Injected by Generator -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script>
      window.process = { env: { API_KEY: "AIzaSyDr73mB7NaPI0oIL-xG5mcRM3Clv12hTxQ" } };
    </script>
    <script type="importmap">
      {
        "imports": {
          "react": "https://esm.sh/react@18.2.0",
          "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
          "lucide-react": "https://esm.sh/lucide-react@0.263.1",
          "@google/genai": "https://esm.sh/@google/genai@0.1.1",
          "recharts": "https://esm.sh/recharts@2.12.0"
        }
      }
    </script>
    <script type="text/babel" data-type="module" data-presets="react,typescript">
      
/* --- Bundled from Dashboard.tsx --- */
import React from 'react';

import { PieChart, Pie, Cell, ResponsiveContainer, Tooltip } from 'recharts';
import { BookOpen, Upload, BrainCircuit, Award } from 'lucide-react';

interface DashboardProps {
  chunks: WordChunk[];
  setMode: (mode: AppMode) => void;
  setActiveChunk: (chunkId: number) => void;
}

const Dashboard: React.FC<DashboardProps> = ({ chunks, setMode, setActiveChunk }) => {
  const totalWords = chunks.reduce((acc, chunk) => acc + chunk.words.length, 0);
  const learnedWords = chunks.reduce((acc, chunk) => 
    acc + chunk.words.filter(w => w.learned).length, 0
  , 0);

  const progressData = [
    { name: '암기 완료', value: learnedWords },
    { name: '학습 중', value: totalWords - learnedWords },
  ];

  const COLORS = ['#10b981', '#e2e8f0'];

  const handleStartChunk = (chunkId: number) => {
    setActiveChunk(chunkId);
    setMode(AppMode.LEARNING);
  };

  return (
    <div className="p-6 max-w-4xl mx-auto space-y-8">
      <header className="text-center mb-10">
        <h1 className="text-4xl font-extrabold text-brand-900 mb-2 tracking-tight">WordFlow</h1>
        <p className="text-slate-500 font-medium">흐름을 타면 암기는 저절로 됩니다</p>
      </header>

      {/* Stats Section */}
      <div className="bg-white rounded-3xl shadow-sm border border-slate-100 p-6 flex flex-col md:flex-row items-center justify-between">
        <div className="w-full md:w-1/2 pr-4">
          <h2 className="text-xl font-bold text-slate-800 mb-4 flex items-center gap-2">
            <Award className="w-6 h-6 text-yellow-500" />
            오늘의 학습 현황
          </h2>
          <div className="space-y-2">
            <div className="flex justify-between text-sm text-slate-600">
              <span>진행률</span>
              <span className="font-bold text-brand-600">
                {totalWords > 0 ? Math.round((learnedWords / totalWords) * 100) : 0}%
              </span>
            </div>
            <div className="w-full bg-slate-100 rounded-full h-2.5">
              <div 
                className="bg-brand-500 h-2.5 rounded-full transition-all duration-500" 
                style={{ width: `${totalWords > 0 ? (learnedWords / totalWords) * 100 : 0}%` }}
              ></div>
            </div>
            <p className="text-xs text-slate-400 mt-2 text-right">{learnedWords} / {totalWords} 단어</p>
          </div>
        </div>
        
        <div className="w-full md:w-1/2 h-40 mt-6 md:mt-0">
          <ResponsiveContainer width="100%" height="100%">
            <PieChart>
              <Pie
                data={progressData}
                cx="50%"
                cy="50%"
                innerRadius={40}
                outerRadius={60}
                fill="#8884d8"
                paddingAngle={5}
                dataKey="value"
                stroke="none"
              >
                {progressData.map((entry, index) => (
                  <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
                ))}
              </Pie>
              <Tooltip />
            </PieChart>
          </ResponsiveContainer>
        </div>
      </div>

      {/* Actions */}
      {totalWords === 0 ? (
         <div className="text-center py-12 bg-brand-50 rounded-3xl border-2 border-dashed border-brand-200">
            <BookOpen className="w-16 h-16 text-brand-300 mx-auto mb-4" />
            <h3 className="text-lg font-bold text-brand-800 mb-2">학습할 단어가 없습니다</h3>
            <p className="text-brand-600 mb-6">CSV나 텍스트 파일을 업로드하여 학습을 시작하세요.</p>
            <button 
              onClick={() => setMode(AppMode.UPLOAD)}
              className="inline-flex items-center gap-2 px-6 py-3 bg-brand-600 text-white rounded-xl hover:bg-brand-700 transition-colors shadow-lg shadow-brand-200 font-bold"
            >
              <Upload className="w-5 h-5" />
              단어장 업로드
            </button>
         </div>
      ) : (
        <div className="space-y-4">
          <h2 className="text-xl font-bold text-slate-800 flex items-center gap-2">
            <BrainCircuit className="w-6 h-6 text-brand-500" />
            학습 묶음 (Chunks)
          </h2>
          <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
            {chunks.map((chunk, idx) => (
              <button
                key={chunk.id}
                onClick={() => handleStartChunk(chunk.id)}
                className={`group relative p-5 rounded-2xl border text-left transition-all duration-200 hover:shadow-md
                  ${chunk.isCompleted 
                    ? 'bg-emerald-50 border-emerald-200 hover:border-emerald-300' 
                    : 'bg-white border-slate-200 hover:border-brand-300'
                  }`}
              >
                <div className="flex justify-between items-start mb-2">
                  <span className={`text-xs font-bold px-2 py-1 rounded-full 
                    ${chunk.isCompleted ? 'bg-emerald-100 text-emerald-700' : 'bg-slate-100 text-slate-500'}`}>
                    Bundle {idx + 1}
                  </span>
                  {chunk.isCompleted && <Award className="w-5 h-5 text-emerald-500" />}
                </div>
                <h3 className="font-bold text-slate-800 group-hover:text-brand-600 transition-colors">
                  {chunk.words[0]?.term} ... {chunk.words[chunk.words.length - 1]?.term}
                </h3>
                <p className="text-sm text-slate-500 mt-1">{chunk.words.length} 단어</p>
              </button>
            ))}
          </div>
          <div className="flex justify-center mt-8">
             <button 
              onClick={() => setMode(AppMode.UPLOAD)}
              className="text-slate-400 hover:text-brand-600 text-sm flex items-center gap-1 transition-colors"
            >
              <Upload className="w-4 h-4" />
              새 단어장 추가하기
            </button>
          </div>
        </div>
      )}
    </div>
  );
};

Dashboard;


/* --- Bundled from FileUpload.tsx --- */

import React, { useCallback, useState } from 'react';
import { Upload, FileText, AlertCircle, CheckCircle, HelpCircle } from 'lucide-react';


interface FileUploadProps {
  onUpload: (newChunks: WordChunk[]) => void;
  onCancel: () => void;
}

const FileUpload: React.FC<FileUploadProps> = ({ onUpload, onCancel }) => {
  const [isDragging, setIsDragging] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // 스마트 파싱 로직
  const parseLine = (line: string): { term: string; definition: string; example?: string } | null => {
    let cleanLine = line.trim();
    if (!cleanLine) return null;

    // [FIX] 리스트 번호 자동 제거 (예: "1. apple", "1) apple", "01 apple")
    // 숫자로 시작하고, 점(.)이나 괄호())가 있거나, 공백이 이어지는 패턴 제거
    cleanLine = cleanLine.replace(/^[\d]+[\.\)\s]+\s*/, ''); 

    // 1. 탭(Tab)으로 구분된 경우 (Excel 복사 붙여넣기 시 흔함)
    if (cleanLine.includes('\t')) {
      const parts = cleanLine.split('\t');
      return { 
        term: parts[0].trim(), 
        definition: parts[1]?.trim() || '', 
        example: parts[2]?.trim() 
      };
    }

    // 2. CSV 형태 (따옴표 고려)
    // "word", "meaning, detail", "example" 같은 형태 처리
    if (cleanLine.includes(',') && (cleanLine.includes('"') || cleanLine.split(',').length >= 2)) {
        // 정규식: 콤마로 구분하되 따옴표 안의 콤마는 무시
        const csvRegex = /,(?=(?:(?:[^"]*"){2})*[^"]*$)/;
        const parts = cleanLine.split(csvRegex).map(p => p.trim().replace(/^"|"$/g, '')); // 따옴표 제거
        
        // 영어 단어인지 확인 (첫 부분)
        if (parts.length >= 2) {
             return {
                term: parts[0],
                definition: parts[1],
                example: parts[2]
             };
        }
    }

    // 3. 콜론(:) 구분
    if (cleanLine.includes(':')) {
        const [term, ...defs] = cleanLine.split(':');
        return { term: term.trim(), definition: defs.join(':').trim() };
    }

    // 4. 공백 구분 - 지능형 (영어와 한글의 경계를 찾음)
    // 예: "apple 사과" -> "apple" / "사과"
    // 예: "look for ~을 찾다" -> "look for" / "~을 찾다"
    // 정규식 설명: (영어/특수문자/공백) + (한글/기타문자시작) 경계 탐색
    const smartRegex = /^([a-zA-Z\s\-\(\)]+)\s+([^a-zA-Z].*)$/;
    const match = cleanLine.match(smartRegex);
    if (match) {
        return { term: match[1].trim(), definition: match[2].trim() };
    }

    // 5. 최후의 수단: 첫 번째 공백으로 분리
    const firstSpace = cleanLine.indexOf(' ');
    if (firstSpace > 0) {
        return {
            term: cleanLine.substring(0, firstSpace).trim(),
            definition: cleanLine.substring(firstSpace).trim()
        };
    }

    return null;
  };

  const processFile = async (file: File) => {
    try {
      const text = await file.text();
      const lines = text.split(/\r?\n/).filter(line => line.trim() !== '');
      const words: Word[] = [];

      lines.forEach((line, index) => {
        const parsed = parseLine(line);
        if (parsed && parsed.term && parsed.definition) {
          // 단어 길이가 너무 짧은(1글자 미만) 경우 등 노이즈 필터링 가능
          if (parsed.term.length > 0) {
            words.push({
              id: `w-${Date.now()}-${index}`,
              term: parsed.term,
              definition: parsed.definition,
              example: parsed.example,
              learned: false,
              correctCount: 0,
              incorrectCount: 0,
            });
          }
        }
      });

      if (words.length === 0) {
        setError("유효한 단어를 찾지 못했습니다. (형식: 영단어 [탭/콤마/공백] 뜻)");
        return;
      }

      // Chunking Logic (Grouping by 10) - Cognitive Load Theory
      const chunkSize = 10;
      const chunks: WordChunk[] = [];
      for (let i = 0; i < words.length; i += chunkSize) {
        chunks.push({
          id: Date.now() + i,
          words: words.slice(i, i + chunkSize),
          isCompleted: false,
        });
      }

      onUpload(chunks);

    } catch (err) {
      console.error(err);
      setError("파일을 읽는 중 오류가 발생했습니다.");
    }
  };

  const handleDrop = useCallback((e: React.DragEvent) => {
    e.preventDefault();
    setIsDragging(false);
    setError(null);
    const file = e.dataTransfer.files[0];
    if (file) processFile(file);
  }, []);

  const handleFileInput = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) processFile(file);
  };

  return (
    <div className="p-6 max-w-2xl mx-auto">
      <div className="bg-white rounded-3xl shadow-lg p-8">
        <h2 className="text-2xl font-bold text-slate-800 mb-2 flex items-center gap-2">
            <FileText className="w-6 h-6 text-brand-500" />
            단어장 업로드
        </h2>
        <p className="text-slate-500 mb-8">
            엑셀에서 복사한 텍스트나 CSV 파일을 올려주세요. 자동으로 분석합니다.
        </p>

        <div
          onDragOver={(e) => { e.preventDefault(); setIsDragging(true); }}
          onDragLeave={() => setIsDragging(false)}
          onDrop={handleDrop}
          className={`
            border-3 border-dashed rounded-2xl p-12 text-center transition-all duration-300 cursor-pointer relative overflow-hidden
            ${isDragging 
                ? 'border-brand-500 bg-brand-50 scale-[1.02]' 
                : 'border-slate-200 bg-slate-50 hover:border-brand-300 hover:bg-white'
            }
          `}
        >
          <input
            type="file"
            id="fileInput"
            className="hidden"
            accept=".csv,.txt"
            onChange={handleFileInput}
          />
          <label htmlFor="fileInput" className="cursor-pointer flex flex-col items-center relative z-10">
            <div className={`p-4 rounded-full mb-4 transition-colors ${isDragging ? 'bg-white' : 'bg-brand-100'}`}>
                 <Upload className={`w-8 h-8 ${isDragging ? 'text-brand-600' : 'text-brand-500'}`} />
            </div>
            <span className="text-lg font-bold text-slate-700">파일을 여기로 드래그</span>
            <span className="text-sm text-slate-400 mt-2">또는 클릭하여 선택 (.txt, .csv)</span>
          </label>
        </div>

        {error && (
            <div className="mt-6 p-4 bg-red-50 text-red-600 rounded-xl flex items-center gap-3 animate-pulse border border-red-100">
                <AlertCircle className="w-5 h-5 shrink-0" />
                <span className="text-sm font-medium">{error}</span>
            </div>
        )}

        <div className="mt-8 flex justify-end gap-3">
            <button 
                onClick={onCancel}
                className="px-6 py-3 text-slate-500 font-medium hover:bg-slate-100 rounded-xl transition-colors"
            >
                취소
            </button>
        </div>
      </div>
      
      <div className="mt-6 p-5 bg-blue-50/50 rounded-2xl border border-blue-100">
          <h3 className="font-bold text-slate-700 mb-3 flex items-center gap-2 text-sm">
            <HelpCircle className="w-4 h-4 text-blue-500" />
            지원하는 형식 (자동 인식)
          </h3>
          <div className="grid grid-cols-1 sm:grid-cols-2 gap-3 text-xs text-slate-600">
             <div className="bg-white p-3 rounded-lg border border-blue-100 shadow-sm">
                <strong className="block text-blue-600 mb-1">탭/공백/번호 자동 처리</strong>
                1. apple 사과
             </div>
             <div className="bg-white p-3 rounded-lg border border-blue-100 shadow-sm">
                <strong className="block text-blue-600 mb-1">공백 구분</strong>
                apple 사과
             </div>
             <div className="bg-white p-3 rounded-lg border border-blue-100 shadow-sm">
                <strong className="block text-blue-600 mb-1">CSV (콤마)</strong>
                word, meaning
             </div>
             <div className="bg-white p-3 rounded-lg border border-blue-100 shadow-sm">
                <strong className="block text-blue-600 mb-1">구 & 숙어</strong>
                look for ~을 찾다
             </div>
          </div>
      </div>
    </div>
  );
};

FileUpload;


/* --- Bundled from LearningMode.tsx --- */
import React, { useState, useEffect, useCallback } from 'react';



import { Volume2, ArrowRight, ArrowLeft, Sparkles, CheckCircle } from 'lucide-react';

interface LearningModeProps {
  chunk: WordChunk;
  onComplete: (updatedWords: Word[]) => void;
  onExit: () => void;
}

const LearningMode: React.FC<LearningModeProps> = ({ chunk, onComplete, onExit }) => {
  const [currentIndex, setCurrentIndex] = useState(0);
  const [isFlipped, setIsFlipped] = useState(false);
  const [words, setWords] = useState<Word[]>(chunk.words);
  const [aiExplanation, setAiExplanation] = useState<string | null>(null);
  const [isLoadingAi, setIsLoadingAi] = useState(false);

  const currentWord = words[currentIndex];

  const handleFlip = useCallback(() => {
    setIsFlipped(prev => !prev);
    audioService.playFlip();
  }, []);

  useEffect(() => {
    if (!isFlipped) {
        const timer = setTimeout(() => {
             audioService.speak(currentWord.term);
        }, 300);
        return () => clearTimeout(timer);
    }
  }, [currentIndex, isFlipped, currentWord.term]);

  const handleNext = () => {
    setAiExplanation(null);
    if (currentIndex < words.length - 1) {
      setIsFlipped(false);
      setCurrentIndex(prev => prev + 1);
    } else {
      onComplete(words);
    }
  };

  const handlePrev = () => {
    if (currentIndex > 0) {
        setIsFlipped(false);
        setAiExplanation(null);
        setCurrentIndex(prev => prev - 1);
    }
  };

  const handleAskAi = async (e: React.MouseEvent) => {
    e.stopPropagation();
    if (aiExplanation) return;
    
    setIsLoadingAi(true);
    const explanation = await generateExplanation(currentWord.term);
    setAiExplanation(explanation);
    setIsLoadingAi(false);
  };

  const markAsKnown = (e: React.MouseEvent) => {
      e.stopPropagation();
      const updatedWords = [...words];
      updatedWords[currentIndex].learned = true;
      setWords(updatedWords);
      audioService.playSuccess();
      handleNext();
  };

  const progress = ((currentIndex + 1) / words.length) * 100;

  // Adaptive Font Size logic
  const getFontSize = (text: string) => {
      if (text.length > 15) return 'text-3xl';
      if (text.length > 10) return 'text-4xl';
      return 'text-5xl';
  };

  return (
    <div className="h-screen max-h-[900px] flex flex-col bg-slate-50 overflow-hidden">
      {/* Header */}
      <div className="p-4 flex items-center justify-between bg-white shadow-sm z-10">
        <button onClick={onExit} className="text-slate-400 hover:text-slate-700 font-bold text-sm px-2 py-1 rounded hover:bg-slate-100">
           ✕ 그만하기
        </button>
        <div className="flex-1 mx-6 max-w-md">
             <div className="h-2 bg-slate-100 rounded-full overflow-hidden">
                 <div className="h-full bg-brand-500 transition-all duration-500 ease-out" style={{ width: `${progress}%` }} />
             </div>
             <p className="text-xs text-center text-slate-400 mt-1 font-medium tracking-wide">
                {currentIndex + 1} / {words.length}
             </p>
        </div>
        <div className="w-16"></div> 
      </div>

      {/* Main Card Area */}
      <div className="flex-1 flex items-center justify-center p-4 sm:p-8 relative w-full max-w-3xl mx-auto">
        
        <div 
            className="relative w-full max-w-md aspect-[3/4] cursor-pointer perspective-1000 group"
            onClick={handleFlip}
        >
             <div className={`relative w-full h-full transition-transform duration-500 preserve-3d shadow-2xl rounded-3xl ${isFlipped ? 'rotate-y-180' : ''}`}>
                
                {/* Front (English) */}
                <div className="absolute w-full h-full backface-hidden bg-white rounded-3xl p-8 flex flex-col items-center justify-center border border-slate-100 shadow-sm">
                     <div className="text-brand-200 text-xs font-extrabold uppercase tracking-[0.2em] mb-6">Word</div>
                     
                     <div className="flex-1 flex items-center justify-center w-full">
                        <h2 className={`${getFontSize(currentWord.term)} font-extrabold text-slate-800 text-center break-words w-full leading-tight px-2`}>
                            {currentWord.term}
                        </h2>
                     </div>
                     
                     <button 
                        onClick={(e) => { e.stopPropagation(); audioService.speak(currentWord.term); }}
                        className="p-4 rounded-full bg-brand-50 text-brand-500 hover:bg-brand-100 hover:text-brand-600 transition-all hover:scale-110 active:scale-95 mb-8"
                        aria-label="Listen pronunciation"
                     >
                         <Volume2 className="w-7 h-7" />
                     </button>

                     <div className="absolute bottom-6 text-slate-300 text-xs font-medium animate-pulse">
                        탭하여 뜻 확인하기
                     </div>
                </div>

                {/* Back (Definition & AI) */}
                <div className="absolute w-full h-full backface-hidden rotate-y-180 bg-slate-800 text-white rounded-3xl overflow-hidden flex flex-col">
                     <div className="flex-1 overflow-y-auto p-8 scrollbar-hide flex flex-col items-center">
                        <div className="text-slate-400 text-xs font-extrabold uppercase tracking-[0.2em] mb-6 mt-4">Meaning</div>
                        
                        <h3 className="text-2xl sm:text-3xl font-bold text-center mb-6 leading-snug break-keep text-white">
                            {currentWord.definition}
                        </h3>
                        
                        {currentWord.example && (
                            <div className="w-full bg-slate-700/50 rounded-xl p-4 mb-6 border border-slate-600/50">
                                <p className="text-brand-100 text-center text-sm sm:text-base italic font-serif">
                                    "{currentWord.example}"
                                </p>
                            </div>
                        )}

                        {/* AI Section */}
                        <div className="w-full mt-auto pt-4 border-t border-slate-700">
                            {!aiExplanation && !isLoadingAi && (
                                <button 
                                    onClick={handleAskAi}
                                    className="w-full py-3 flex items-center justify-center gap-2 bg-brand-600 hover:bg-brand-500 rounded-xl transition-all text-sm font-bold shadow-lg shadow-brand-900/50"
                                >
                                    <Sparkles className="w-4 h-4 text-yellow-300" />
                                    AI 선생님 설명 듣기
                                </button>
                            )}
                            {isLoadingAi && (
                                <div className="text-slate-400 text-sm text-center py-2 flex items-center justify-center gap-2">
                                    <div className="w-2 h-2 bg-brand-400 rounded-full animate-bounce" />
                                    <div className="w-2 h-2 bg-brand-400 rounded-full animate-bounce delay-100" />
                                    <div className="w-2 h-2 bg-brand-400 rounded-full animate-bounce delay-200" />
                                </div>
                            )}
                            {aiExplanation && (
                                <div className="bg-slate-700 rounded-xl p-4 text-sm text-slate-200 text-left leading-relaxed border border-slate-600 animate-fadeIn">
                                    <div className="flex items-center gap-2 mb-2 text-brand-300 font-bold text-xs uppercase tracking-wider">
                                        <Sparkles className="w-3 h-3" /> Insight
                                    </div>
                                    {aiExplanation}
                                </div>
                            )}
                        </div>
                     </div>
                </div>
             </div>
        </div>
      </div>

      {/* Footer Controls */}
      <div className="p-6 bg-white border-t border-slate-100 flex justify-center items-center gap-6 sm:gap-12 pb-8 shadow-[0_-10px_40px_-15px_rgba(0,0,0,0.05)]">
         <button 
            onClick={handlePrev}
            disabled={currentIndex === 0}
            className="p-4 text-slate-300 disabled:opacity-20 hover:text-slate-500 hover:bg-slate-50 rounded-full transition-all active:scale-95"
         >
             <ArrowLeft className="w-7 h-7" />
         </button>

        <button
            onClick={markAsKnown}
            className="flex flex-col items-center gap-2 group"
        >
             <div className="w-16 h-16 bg-emerald-50 border-2 border-emerald-100 rounded-full flex items-center justify-center text-emerald-500 group-hover:bg-emerald-500 group-hover:border-emerald-500 group-hover:text-white transition-all shadow-sm group-hover:shadow-emerald-200 group-hover:shadow-lg group-active:scale-95">
                <CheckCircle className="w-7 h-7" />
             </div>
             <span className="text-xs font-bold text-emerald-600 opacity-0 group-hover:opacity-100 transition-opacity absolute -top-8">외웠어요!</span>
        </button>

         <button 
            onClick={handleNext}
            className="p-4 text-brand-500 hover:text-brand-700 hover:bg-brand-50 rounded-full transition-all active:scale-95"
         >
             <ArrowRight className="w-7 h-7" />
         </button>
      </div>
    </div>
  );
};

LearningMode;

/* --- Bundled from QuizMode.tsx --- */
import React, { useState } from 'react';


import { Check, X, Trophy, RotateCcw, Home } from 'lucide-react';

interface QuizModeProps {
  chunk: WordChunk;
  onFinish: () => void;
}

const QuizMode: React.FC<QuizModeProps> = ({ chunk, onFinish }) => {
  const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0);
  const [score, setScore] = useState(0);
  const [showResult, setShowResult] = useState(false);
  const [selectedAnswer, setSelectedAnswer] = useState<string | null>(null);
  const [isCorrect, setIsCorrect] = useState<boolean | null>(null);

  // Shuffle words for quiz content, but keep question order consistent for now
  // In a real app, we might want to randomize question order too.
  const currentWord = chunk.words[currentQuestionIndex];
  
  // Generate 3 distractors
  const generateOptions = () => {
    const distractors = chunk.words
        .filter(w => w.id !== currentWord.id)
        .sort(() => 0.5 - Math.random())
        .slice(0, 3)
        .map(w => w.definition);
    
    const options = [...distractors, currentWord.definition];
    return options.sort(() => 0.5 - Math.random());
  };

  const [options, setOptions] = useState<string[]>(generateOptions());

  const handleAnswer = (answer: string) => {
    if (selectedAnswer) return; // Prevent double click

    setSelectedAnswer(answer);
    const correct = answer === currentWord.definition;
    setIsCorrect(correct);

    if (correct) {
      setScore(prev => prev + 1);
      audioService.playSuccess();
    } else {
      audioService.playError();
    }

    // Auto advance after delay
    setTimeout(() => {
      if (currentQuestionIndex < chunk.words.length - 1) {
        const nextIndex = currentQuestionIndex + 1;
        setCurrentQuestionIndex(nextIndex);
        setSelectedAnswer(null);
        setIsCorrect(null);
        // Need to update options for next question manually since component doesn't remount
        // This is a bit tricky in React functional components without effects, 
        // but we can just rely on a simple effect or function call.
        // Let's force a re-render logic by relying on the `key` prop in parent or state update.
        // Actually, simpler: update options inside this timeout.
        
        const nextWord = chunk.words[nextIndex];
        const nextDistractors = chunk.words
            .filter(w => w.id !== nextWord.id)
            .sort(() => 0.5 - Math.random())
            .slice(0, 3)
            .map(w => w.definition);
        setOptions([...nextDistractors, nextWord.definition].sort(() => 0.5 - Math.random()));
        
        audioService.speak(nextWord.term); // Speak next word
      } else {
        setShowResult(true);
      }
    }, 1500);
  };

  if (showResult) {
      const percentage = Math.round((score / chunk.words.length) * 100);
      return (
          <div className="min-h-screen flex flex-col items-center justify-center bg-slate-50 p-6">
              <div className="bg-white rounded-3xl shadow-xl p-10 w-full max-w-md text-center">
                  <div className="w-20 h-20 bg-yellow-100 rounded-full flex items-center justify-center mx-auto mb-6">
                      <Trophy className="w-10 h-10 text-yellow-500" />
                  </div>
                  <h2 className="text-3xl font-bold text-slate-800 mb-2">퀴즈 완료!</h2>
                  <p className="text-slate-500 mb-8">수고하셨습니다.</p>
                  
                  <div className="text-5xl font-extrabold text-brand-600 mb-2">{score} / {chunk.words.length}</div>
                  <p className="text-sm font-medium text-slate-400 mb-8">{percentage}% 정답률</p>

                  <button 
                    onClick={onFinish}
                    className="w-full py-4 bg-brand-600 hover:bg-brand-700 text-white rounded-xl font-bold transition-colors flex items-center justify-center gap-2"
                  >
                    <Home className="w-5 h-5" />
                    메인으로 돌아가기
                  </button>
              </div>
          </div>
      )
  }

  return (
    <div className="min-h-screen bg-slate-50 flex flex-col">
        <div className="p-6">
            <div className="flex justify-between items-center mb-4">
                <span className="text-sm font-bold text-slate-400">Quiz {currentQuestionIndex + 1} / {chunk.words.length}</span>
                <span className="text-sm font-bold text-brand-600">Score: {score}</span>
            </div>
            <div className="h-2 bg-slate-200 rounded-full overflow-hidden">
                <div 
                    className="h-full bg-brand-500 transition-all duration-300" 
                    style={{ width: `${((currentQuestionIndex) / chunk.words.length) * 100}%` }}
                />
            </div>
        </div>

        <div className="flex-1 flex flex-col items-center justify-center p-6 max-w-md mx-auto w-full">
            <div className="mb-10 text-center">
                <h2 className="text-4xl font-bold text-slate-800 mb-4">{currentWord.term}</h2>
                <p className="text-slate-400 text-sm">알맞은 뜻을 선택하세요</p>
            </div>

            <div className="w-full space-y-3">
                {options.map((option, idx) => {
                    const isSelected = selectedAnswer === option;
                    const isTarget = option === currentWord.definition;
                    
                    let buttonStyle = "bg-white border-slate-200 text-slate-600 hover:border-brand-400 hover:shadow-md";
                    
                    if (selectedAnswer) {
                        if (isTarget) {
                            buttonStyle = "bg-green-50 border-green-500 text-green-700";
                        } else if (isSelected && !isTarget) {
                            buttonStyle = "bg-red-50 border-red-500 text-red-700";
                        } else {
                            buttonStyle = "bg-slate-50 border-slate-100 text-slate-300 opacity-50";
                        }
                    }

                    return (
                        <button
                            key={idx}
                            disabled={!!selectedAnswer}
                            onClick={() => handleAnswer(option)}
                            className={`w-full p-4 rounded-xl border-2 text-left font-medium transition-all duration-200 flex items-center justify-between ${buttonStyle}`}
                        >
                            <span>{option}</span>
                            {selectedAnswer && isTarget && <Check className="w-5 h-5" />}
                            {selectedAnswer && isSelected && !isTarget && <X className="w-5 h-5" />}
                        </button>
                    );
                })}
            </div>
        </div>
    </div>
  );
};

QuizMode;


/* --- Bundled from audioService.ts --- */

class AudioService {
  private audioContext: AudioContext | null = null;

  private getContext(): AudioContext {
    if (!this.audioContext) {
      this.audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();
    }
    return this.audioContext;
  }

  public playSuccess() {
    const ctx = this.getContext();
    const oscillator = ctx.createOscillator();
    const gainNode = ctx.createGain();

    oscillator.connect(gainNode);
    gainNode.connect(ctx.destination);

    oscillator.type = 'sine';
    oscillator.frequency.setValueAtTime(523.25, ctx.currentTime); // C5
    oscillator.frequency.exponentialRampToValueAtTime(1046.5, ctx.currentTime + 0.1); // C6

    gainNode.gain.setValueAtTime(0.1, ctx.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.3);

    oscillator.start();
    oscillator.stop(ctx.currentTime + 0.3);
  }

  public playError() {
    const ctx = this.getContext();
    const oscillator = ctx.createOscillator();
    const gainNode = ctx.createGain();

    oscillator.connect(gainNode);
    gainNode.connect(ctx.destination);

    oscillator.type = 'sawtooth';
    oscillator.frequency.setValueAtTime(150, ctx.currentTime);
    oscillator.frequency.linearRampToValueAtTime(100, ctx.currentTime + 0.2);

    gainNode.gain.setValueAtTime(0.1, ctx.currentTime);
    gainNode.gain.linearRampToValueAtTime(0.001, ctx.currentTime + 0.2);

    oscillator.start();
    oscillator.stop(ctx.currentTime + 0.2);
  }

  public playFlip() {
    const ctx = this.getContext();
    const oscillator = ctx.createOscillator();
    const gainNode = ctx.createGain();

    oscillator.connect(gainNode);
    gainNode.connect(ctx.destination);

    oscillator.type = 'triangle';
    oscillator.frequency.setValueAtTime(300, ctx.currentTime);
    
    gainNode.gain.setValueAtTime(0.05, ctx.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.05);

    oscillator.start();
    oscillator.stop(ctx.currentTime + 0.05);
  }
  
  public speak(text: string) {
    if ('speechSynthesis' in window) {
      window.speechSynthesis.cancel(); // Stop any previous
      
      // Safety check: Don't speak if the text is empty or strictly numeric (like an index number)
      if (!text || /^\d+$/.test(text.trim())) return;

      const utterance = new SpeechSynthesisUtterance(text);
      utterance.lang = 'en-US';
      utterance.rate = 0.9;
      window.speechSynthesis.speak(utterance);
    }
  }
}

const audioService = new AudioService();


/* --- Bundled from geminiService.ts --- */
import { GoogleGenAI } from "@google/genai";

const getClient = () => {
  const apiKey = process.env.API_KEY;
  if (!apiKey) {
    console.error("API KEY not found");
    return null;
  }
  return new GoogleGenAI({ apiKey });
};

const generateExplanation = async (word: string): Promise<string> => {
  const ai = getClient();
  if (!ai) return "API Key가 설정되지 않았습니다.";

  try {
    const prompt = `
      너는 한국의 고3 수험생을 위한 영어 1타 강사야.
      단어: "${word}"
      
      이 단어에 대해 다음 내용을 포함해서 200자 이내로 설명해줘:
      1. 핵심 뜻 (가장 수능에 많이 나오는 뜻)
      2. 암기 팁 (어원이나 연상법)
      3. 뉘앙스 (비슷한 단어와의 차이점 등)
      
      말투는 친절하고 격려하는 투로 해줘. JSON이 아닌 일반 텍스트로 답변해.
    `;

    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash',
      contents: prompt,
    });

    return response.text || "설명을 생성할 수 없습니다.";
  } catch (error) {
    console.error("Gemini Error:", error);
    return "AI 설명을 불러오는 중 오류가 발생했습니다.";
  }
};


/* --- Bundled from App.tsx --- */
import React, { useState, useEffect } from 'react';






const App: React.FC = () => {
  const [mode, setMode] = useState<AppMode>(AppMode.DASHBOARD);
  const [chunks, setChunks] = useState<WordChunk[]>([]);
  const [activeChunkId, setActiveChunkId] = useState<number | null>(null);

  // Load data from local storage on mount
  useEffect(() => {
    const saved = localStorage.getItem('wordflow-data');
    if (saved) {
      try {
        setChunks(JSON.parse(saved));
      } catch (e) {
        console.error("Failed to load saved data");
      }
    }
  }, []);

  // Save data on change
  useEffect(() => {
    localStorage.setItem('wordflow-data', JSON.stringify(chunks));
  }, [chunks]);

  const handleUpload = (newChunks: WordChunk[]) => {
    setChunks(prev => [...prev, ...newChunks]);
    setMode(AppMode.DASHBOARD);
  };

  const handleChunkComplete = (updatedWords: Word[]) => {
    setChunks(prev => prev.map(c => {
      if (c.id === activeChunkId) {
        return { ...c, words: updatedWords, isCompleted: true }; // Mark as learned tentatively
      }
      return c;
    }));
    // Transition to Quiz immediately for Flow
    setMode(AppMode.QUIZ);
  };

  const handleQuizFinish = () => {
      setMode(AppMode.DASHBOARD);
      setActiveChunkId(null);
  };

  const getActiveChunk = () => chunks.find(c => c.id === activeChunkId);

  return (
    <div className="min-h-screen bg-slate-50 font-sans text-slate-900">
      {mode === AppMode.DASHBOARD && (
        <Dashboard 
            chunks={chunks} 
            setMode={setMode} 
            setActiveChunk={setActiveChunkId} 
        />
      )}

      {mode === AppMode.UPLOAD && (
        <FileUpload 
            onUpload={handleUpload} 
            onCancel={() => setMode(AppMode.DASHBOARD)} 
        />
      )}

      {mode === AppMode.LEARNING && activeChunkId && getActiveChunk() && (
        <LearningMode 
            chunk={getActiveChunk()!} 
            onComplete={handleChunkComplete}
            onExit={() => setMode(AppMode.DASHBOARD)}
        />
      )}

      {mode === AppMode.QUIZ && activeChunkId && getActiveChunk() && (
        <QuizMode 
            chunk={getActiveChunk()!}
            onFinish={handleQuizFinish}
        />
      )}
    </div>
  );
};

App;


/* --- Bundled from types.ts --- */
export interface Word {
  id: string;
  term: string;
  definition: string;
  example?: string;
  learned: boolean;
  correctCount: number;
  incorrectCount: number;
}

export interface WordChunk {
  id: number;
  words: Word[];
  isCompleted: boolean;
}

export enum AppMode {
  DASHBOARD = 'DASHBOARD',
  LEARNING = 'LEARNING',
  QUIZ = 'QUIZ',
  UPLOAD = 'UPLOAD',
}

export interface LearningSession {
  chunkId: number;
  currentIndex: number;
  isFlipped: boolean;
}


/* --- Bundled from vite.config.ts --- */
import path from 'path';
import { defineConfig, loadEnv } from 'vite';
import react from '@vitejs/plugin-react';

defineConfig(({ mode }) => {
    const env = loadEnv(mode, '.', '');
    return {
      server: {
        port: 3000,
        host: '0.0.0.0',
      },
      plugins: [react()],
      define: {
        'process.env.API_KEY': JSON.stringify(env.GEMINI_API_KEY),
        'process.env.GEMINI_API_KEY': JSON.stringify(env.GEMINI_API_KEY)
      },
      resolve: {
        alias: {
          '@': path.resolve(__dirname, '.'),
        }
      }
    };
});


/* --- Bundled from index.tsx --- */
import React from 'react';
import ReactDOM from 'react-dom/client';


const rootElement = document.getElementById('root');
if (!rootElement) {
  throw new Error("Could not find root element to mount to");
}

const root = ReactDOM.createRoot(rootElement);
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);


    </script>
    <script>
      window.addEventListener('load', function() {
        if (window.Babel) {
          window.Babel.transformScriptTags();
        }
      });
    </script>
    
</body>
</html>